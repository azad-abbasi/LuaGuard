 do
    -- Avoid heap allocs for performance
    local fcomp_default = function( a,b ) return a < b end
    function table.bininsert(t, value, fcomp)
       -- Initialise compare function
       local fcomp = fcomp or fcomp_default
       --  Initialise numbers
       local iStart,iEnd,iMid,iState = 1,#t,1,0
       -- Get insert position
       while iStart <= iEnd do
          -- calculate middle
          iMid = math.floor( (iStart+iEnd)/2 )
          -- compare
          if fcomp( value,t[iMid] ) then
             iEnd,iState = iMid - 1,0
          else
             iStart,iState = iMid + 1,1
          end
       end
       table.insert( t,(iMid+iState),value )
       return (iMid+iState)
    end
 end

==============================================================
(CHUNK (do (CHUNK (LOCAL_ASSIGNMENT (NAME_LIST fcomp_default) (EXPR_LIST (FUNCTION (PARAM_LIST a b) (CHUNK (return (< a b)))))) (ASSIGNMENT (VAR_LIST (VAR table (INDEX bininsert))) (EXPR_LIST (FUNCTION (PARAM_LIST t value fcomp) (CHUNK (LOCAL_ASSIGNMENT (NAME_LIST fcomp) (EXPR_LIST (or fcomp fcomp_default))) (LOCAL_ASSIGNMENT (NAME_LIST iStart iEnd iMid iState) (EXPR_LIST 1 (# t) 1 0)) (while (<= iStart iEnd) (do (CHUNK (ASSIGNMENT (VAR_LIST iMid) (EXPR_LIST (VAR math (INDEX floor) (CALL (/ (+ iStart iEnd) 2))))) (if (CONDITION (VAR fcomp (CALL value (VAR t (INDEX iMid)))) (CHUNK (ASSIGNMENT (VAR_LIST iEnd iState) (EXPR_LIST (- iMid 1) 0)))) (CONDITION True (CHUNK (ASSIGNMENT (VAR_LIST iStart iState) (EXPR_LIST (+ iMid 1) 1)))))))) (VAR table (INDEX insert) (CALL t (+ iMid iState) value)) (return (+ iMid iState)))))))))